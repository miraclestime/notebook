createdAt: "2019-12-19T08:55:59.639Z"
updatedAt: "2019-12-25T03:26:02.677Z"
type: "MARKDOWN_NOTE"
folder: "5b24b76c5b369d916d33"
title: "java"
tags: []
content: '''
  # java
  ## 记录
  1. 日期是个对象，在内部用long类型标识；
  2. 变量就是给数据起名字，方便找不同的数据，值可以改变，但含义不变；
  3. [为什么java里面3*0.1=0.30000000000000004，而4*0.1=0.4？ - 知乎](https://www.zhihu.com/question/56545018/answer/149620518)
  4. MySql 5.0 以上的版本：
  一个汉字占多少长度与编码有关：
  UTF-8：一个汉字 = 3个字节，英文是一个字节
  GBK： 一个汉字 = 2个字节，英文是一个字节
  表情占4个字节。
  5. 构造函数的意义
  构造函数并不是为了“初始化类”，至少不完全是。不然它就会改叫“Initializer”而不是“Constructor”。构造的内涵比初始化要丰富。尽管大多数情况下，我们对类的构造内容限于给它的属性赋值，但这仅仅是对简单的使用场景。对于复杂的设计模式，构造函数还要完成其他任务，从抽象的类去“建设”一个功能化的实例。比如依赖注入，最流行的模式就是使用构造函数。
  6. 为什么static方法不能被复写
  因为调用方式一致，不会像上面造成歧义，虽然父类和子类都定义了同样的函数，但是编译器会根据对象的静态类型激活对应的静态方法的引用，造成了重写的假象，实则不是重写！
  总体流程就是：编译器将类编译成class文件，其中方法会根据静态类型从而将对应的方法引用写入class中，运行时，JVM会根据INVOKEVIRTUAL 所指向的方法引用在常量池找到该方法的偏移量，再根据this找到引用类型真实指向的对象，访问这个对象类型的方法表，根据偏移量找出存放目标方法引用的位置，取出这个引用，调用这个引用实际指向的方法，完成多态！
  7. private代表私有，不能被子类调用，final标识不能被复写。
  8. 内部类就是在类内部使用的类，比如封装一个返回值类型、封装一个过程对象（如Node）等。
  9. transient关键字？标识字段不被持久化。
  10. 持久化？
  11. str1和str2指向两个不同的String对象，但是两个对象内部的value值指向相同的char数组，所以str1!=str2,但是str1 equals str2。
  12. @native？
'''
linesHighlighted: []
isStarred: false
isTrashed: false
